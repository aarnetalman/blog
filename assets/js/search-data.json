{
  
    
        "post0": {
            "title": "Semantic Search with Pre-trained Sentence Encoders",
            "content": "In the previous two posts I&#39;ve explored the HuggingFace Transformers library and demonstrated: . how to train a classification model for NLI . | how to use an NLI model to rank news articles based on a keyword . | In this post I will show how to use a pre-trained sentence encoder model to create a simple semantic search engine for website content. The search engine will be &quot;semantic&quot; in the sense that it will try to find sentences from the website whose vector representation &quot;matches&quot; the vector representation of the search term. . We will use a pre-trained transformers model to encode all the sentences of a website as well as the search term and then calculate the cosine similarity between each encoded sentence and the search term. We will then rank the sentences based on the cosine similarity. . Let&#39;s get started. As before we will first install the libraries we need for this demo. We are using a library called Sentence Transformers, which provides pre-trained transformers models specifically for the purpose of computing sentence-level vector representations. We also need to install scikit-learn, as we will use it to calculate the cosine similarities between sentence vectors. . !pip install sentence_transformers sklearn lxml bs4 . Once we have installed the liraries we will import them together with some other usefult librarires we will use in the demo. . from sentence_transformers import SentenceTransformer import numpy as np from sklearn.metrics.pairwise import cosine_similarity from bs4 import BeautifulSoup from bs4.element import Comment import requests from IPython.display import Markdown, display . As in the previous post we define some functions we will use for cleaning up the text from the website html as well as a function to print our output in markdown format. . def tag_visible(element): if element.parent.name in [&#39;p&#39;]: return True if isinstance(element, Comment): return False return False def text_from_html(html): soup = BeautifulSoup(html.content, &#39;lxml&#39;) texts = soup.findAll(text=True) visible_texts = filter(tag_visible, texts) return u&quot; &quot;.join(t.strip() for t in visible_texts) def printmd(string): display(Markdown(string)) . Now we can define the website we are interested in together with the search term. We also define how many search results we want to see. In this demo we are interested in finding top five sentences from the Deep Learning Wikipedia article that are about Natural Language Processing. . website = &#39;https://en.wikipedia.org/wiki/Deep_learning&#39; search_term = &#39;natural language processing&#39; num_results = 5 . We then retrieve and extract the text from the website and split the sentences to a list. . html = requests.get(website) src_text = text_from_html(html) input_text = src_text.split(&#39;.&#39;) . For our model we use the roberta-large-nli-stsb-mean-tokens model which according to the Sentence transformers Github page beats the other Sentence Transformer models in the Semantic Textual Similarity (STS) benchmark. . model = SentenceTransformer(&#39;roberta-base-nli-stsb-mean-tokens&#39;) . Next we encode the list of sentences retrieved from the website as well as the search term using the Sentence Transformer model. . encoded_text = np.array(model.encode(input_text)) encoded_query = np.array(model.encode([search_term])) . We then compare the cosine similarity of each encoded sentence with the encoded search term and rank the sentences accordingly. . results = cosine_similarity(encoded_query, encoded_text)[0] num_results = results.argsort()[-num_results:][::-1] scores = results[num_results] sentences = [input_text[idx] for idx in num_results] . Finally, we can print the list of five sentences that best match the search term. . print(&#39;*&#39;*30 + &#39; Start of output &#39; + &#39;*&#39;*30) printmd(&#39;**Search Results:**&#39;) for sentence, score in zip(sentences, scores): printmd(f&#39;* {sentence} (score: {score:&lt;.4f})&#39;) print(&#39;*&#39;*30 + &#39; End of output &#39; + &#39;*&#39;*30) . ****************************** Start of output ****************************** . Search Results: . Neural networks have been used for implementing language models since the early 2000s (score: 0.6076) | . Word embedding, such as , can be thought of as a representational layer in a deep learning architecture that transforms an atomic word into a positional representation of the word relative to other words in the dataset; the position is represented as a point in a (score: 0.5070) | . LSTM helped to improve machine translation and language modeling (score: 0.4982) | . A deep neural network (DNN) is an (ANN) with multiple layers between the input and output layers (score: 0.4969) | . An ANN is based on a collection of connected units called , (analogous to biological neurons in a ) (score: 0.4947) | . ****************************** End of output ****************************** . As you can see the output is fairly good and at least the top three sentences are highly relevant for our search. . In this demo we have seen that with just a few lines of code you can create a simple search engine that does whet it is supposed to do: it finds sentences from the source website/document that match our keyword. The same idea can be used in wide variety of use cases. . Hope you enjoyed this demo. Feel free to contact me if you have any questions. . Twitter: @AarneTalman | Website: talman.io | .",
            "url": "https://talman.io/search/demo/2020/12/14/simple-semantic-search-engine-with-transformers.html",
            "relUrl": "/search/demo/2020/12/14/simple-semantic-search-engine-with-transformers.html",
            "date": " • Dec 14, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Article Ranking with Natural Language Inference",
            "content": "In my previous post I showed how to fine-tune a pre-trained transformers model for the natural language inference (NLI) classification task. In this post I&#39;m taking a fine-tuned NLI model and use it to classify and rank articles in a news feed. . The idea is simple: we use an NLI model that has been trained on the MultiNLI task and pass an excerpt of the source text together with a search term we are interested in to the model. The model will then check if the source text entails the search term and returns a score. We can use these scores to rank the articles. We could use the model we trained on the previous demo, but luckily the people at Huggingface have made our lives much easier by releasing a new pipeline for zero-shot classification which uses a pre-trained NLI model. . So let&#39;s get started! First we need to install the required libraries and import them. In addition to the PyTorch and transformers libraries we are also installing and importing some libraries we need for retrieving and processing the news feeds and the articles. . !pip install transformers torch lxml bs4 feedparser . from transformers import pipeline, logging import torch import sys from bs4 import BeautifulSoup from bs4.element import Comment import requests import re import feedparser import time from operator import itemgetter from IPython.display import Markdown, display from tqdm import tqdm . logging.set_verbosity_error() . Next we will define some functions we need when we process html content retrieved from the websites. The text_from_html function uses BeautifulSoup to filter out unwanted content like html tags, comments, etc. We also define a function we will use to print out the results in markdown format. . def tag_visible(element): if element.parent.name in [&#39;p&#39;]: return True if isinstance(element, Comment): return False return False def text_from_html(html): soup = BeautifulSoup(html.content, &#39;lxml&#39;) texts = soup.findAll(text=True) visible_texts = filter(tag_visible, texts) return u&quot; &quot;.join(t.strip() for t in visible_texts) def printmd(string): display(Markdown(string)) . We need to define our classifier function that will take the source text and the search term and provide the result. The model we are using has a 1024 limit for the input text. Note that this will significantly impact the results as we might be cutting out some important information. However, for our demonstration purposes we will not care about this. You could of course split the text into smaller junks and perform classification of those junks separately and then combine the results at the end. . def classifier(source_text, search_term): src_text = source_text[:1024] classification = pipeline(&quot;zero-shot-classification&quot;, device=0) results = classification(src_text, search_term) return results . Now that we have defined our classifier function we have to define the news feed we want to retrieve the articles from. For this demo I want to understand what news releases have come out from Amazon Web Services (AWS) about machine learning in the past 7 days. So I&#39;m using AWS blog as the source and &quot;machine learning&quot; as the search term / classification label. We also define the number of articles we want to display. Let&#39;s say we want to see the top 4 articles about machine learning. . feed = &quot;https://aws.amazon.com/blogs/aws/feed/&quot; search_term = &quot;machine learning&quot; days = 7 number_of_articles = 4 . Next, we retrieve the newsfeed using the feedparser library. We then retrieve the html source for all the articles from the feed that have been published in the last 7 days. We use the text_from_html function to extract the text from the html source and call the classifier function. Finally, we save the classification score and other relevant information for each article. . newsfeed = feedparser.parse(feed) articles = [] entries = [entry for entry in newsfeed.entries if time.time() - time.mktime(entry.published_parsed) &lt; (86400*days)] for entry in tqdm(entries, total=len(entries)): html = requests.get(entry.link) src_text = text_from_html(html) # This is where we call our classifier function using the source text and the search term classification = classifier(src_text, search_term) article = dict() article[&quot;title&quot;] = entry.title article[&quot;link&quot;] = entry.link article[&quot;src_text&quot;] = src_text article[&quot;published&quot;] = entry.published_parsed article[&quot;relevancy&quot;] = classification[&quot;scores&quot;][0] articles.append(article) . 100%|██████████| 19/19 [07:39&lt;00:00, 24.16s/it] . Now that we have a list of classified articles we can sort them using the classification scores. . sorted_articles = sorted(articles, key=itemgetter(&quot;relevancy&quot;), reverse=True) . Before we display the results, I&#39;m defining another useful function that utilises the transformers summarization pipeline. We will use this function to create a short summary of each article on our list. . def summarise(source_text): src_text = source_text[:1024] summarization = pipeline(&quot;summarization&quot;) summary_text = summarization(src_text, min_length = 100)[0][&#39;summary_text&#39;] summary_text = re.sub(r&#39; s([?.!&quot;,](?: s|$))&#39;, r&#39; 1&#39;, summary_text) return summary_text . Finally, we can summarise the texts for our top 4 articles and print the results in a sorted order based on their ranking. . print(&#39;*&#39;*20 + &#39; Start of output &#39; + &#39;*&#39;*20) for article in sorted_articles[:number_of_articles]: summary = summarise(article[&quot;src_text&quot;]) printmd(&quot;**{}**&lt;br&gt;{}&lt;br&gt;{}&lt;br&gt;**Search term:** {} | **Score:** {:6.3f}&lt;br&gt;&lt;br&gt;&quot;.format(article[&quot;title&quot;], article[&quot;link&quot;], summary, search_term, 100*article[&quot;relevancy&quot;])) print(&#39;*&#39;*20 + &#39; End of output &#39; + &#39;*&#39;*20) . ******************** Start of output ******************** . New – Managed Data Parallelism in Amazon SageMaker Simplifies Training on Large Datasetshttps://aws.amazon.com/blogs/aws/managed-data-parallelism-in-amazon-sagemaker-simplifies-training-on-large-datasets/ Machine learning (ML) practitioners working on large distributed training jobs have to face increasingly long training times. Long training times are a severe bottleneck for ML projects, hurting productivity and slowing down innovation. SageMaker Data Parallelism (SDP) library now helps ML teams reduce distributed training time and cost, thanks to the SageMaker data parallelism library. It takes over 6 hours to train advanced object detection models such as Mask RCNN and Faster RCNN on the publicly available COCO dataset.Search term: machine learning | Score: 99.549 . Amazon SageMaker Simplifies Training Deep Learning Models With Billions of Parametershttps://aws.amazon.com/blogs/aws/amazon-sagemaker-simplifies-training-deep-learning-models-with-billions-of-parameters/ Deep learning (DL) has taken the world by storm in the last 10 years. Based on neural networks, DL algorithms have an extraordinary ability to extract information patterns hidden in vast amounts of unstructured data. DL has quickly achieved impressive results on a variety of complex human-like tasks, especially on computer vision and natural language processing. Today, I&#39;m extremely happy to announce that simplifies the training of very large deep learning models that were previously difficult to train due to hardware limitations. In order to tackle ever more complex tasks, DL researchers are designing increasingly sophisticated models.Search term: machine learning | Score: 99.120 . New – Amazon SageMaker Pipelines Brings DevOps Capabilities to your Machine Learning Projectshttps://aws.amazon.com/blogs/aws/amazon-sagemaker-pipelines-brings-devops-to-machine-learning-projects/ Machine learning (ML) is intrinsically experimental and unpredictable in nature. You spend days or weeks exploring and processing data in many different ways. Then, you experiment with different algorithms and parameters, training and optimizing lots of models in search of highest accuracy. Finally? Not quite, as you’ll certainly iterate again and again, either to try out new ideas, or simply to retrain your models on new data. Today, I’m extremely happy to announce a new capability of that makes it easy for data scientists and engineers to build, automate, and scale end to end machine learning pipelines.Search term: machine learning | Score: 98.130 . Amazon SageMaker JumpStart Simplifies Access to Pre-built Models and Machine Learning Solutionshttps://aws.amazon.com/blogs/aws/amazon-sagemaker-jumpstart-simplifies-access-to-prebuilt-models-and-machine-learning-models/ Machine learning (ML) has proven to be a valuable technique in improving and automating business processes. Working with these models requires skills and experience that only a subset of scientists and developers have. In order to simplify the model building process, the ML community has created model zoos, that is to say, collections of models built with popular open source librarie. Today, a capability of that accelerates your machine learning workflows with one-click access to popular model collections (also known as “model zoos”)Search term: machine learning | Score: 98.004 . ******************** End of output ******************** . There we have it: a working article ranker using a pre-trained NLI model. Super easy and fun! There are literally hundreds of use cases where these models and pipelines can be used to create useful applications. . Hope you enjoyed this demo. Feel free to contact me if you have any questions. . Twitter: @AarneTalman | Website: talman.io | .",
            "url": "https://talman.io/nli/pytorch/demo/2020/12/12/article-ranking-with-an-nli-model.html",
            "relUrl": "/nli/pytorch/demo/2020/12/12/article-ranking-with-an-nli-model.html",
            "date": " • Dec 12, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Natural Language Inference with PyTorch and Transformers",
            "content": "In this notebook I&#39;m showing how to use PyTorch and Huggingface Transformers to fine-tune a pre-trained transformers model to do natural language inference (NLI). In NLI the aim is to model the inferential relationship between two or more given sentences. In particular, given two sentences - the premise p and the hypothesis h - the task is to determine whether h is entailed by p, whether the sentences are in contradiction with each other or whether there is no inferential relationship between the sentences (neutral). . So let&#39;s get started! First we need to install the python libraries using the following command. . !pip3 install torch transformers datasets . We will then import the needed libraries. We are using DistilBERT model for this task so we need to import the relevant DistilBERT model designed for sequence classification task and the corresponding tokeniser. . import torch from torch.utils.data import DataLoader from transformers import DistilBertTokenizerFast, DistilBertForSequenceClassification, AdamW, logging import datasets from tqdm import tqdm import numpy as np . logging.set_verbosity_error() . Let&#39;s load the MultiNLI dataset using the Huggingface Datasets library. For this demonstration we are using only the training and validation data. We are also further limiting the training data to just 20,000 sentence pairs. This will not allow us to train a good quality model, but it speeds up the demonstration. You can change the values here or use the whole dataset. However, be aware that fine tuning the model will take a lot of time. . nli_data = datasets.load_dataset(&quot;multi_nli&quot;) train_data = nli_data[&#39;train&#39;][:20000] # limiting the training set size to 20,000 for demo purposes train_labels = train_data[&#39;label&#39;][:20000] # limiting the training set size to 20,000 for demo purposes dev_data = nli_data[&#39;validation_matched&#39;] val_labels = dev_data[&#39;label&#39;] . Next we will initialise the tokeniser and tokenise our training and validation data. Notice that we are two lists of sentences to both the training and validation set. This is because in NLI we are classifying pairs of sentences: the premise and the hypothesis. . tokeniser = DistilBertTokenizerFast.from_pretrained(&#39;distilbert-base-uncased&#39;) train_encodings = tokeniser(train_data[&#39;premise&#39;], train_data[&#39;hypothesis&#39;], truncation=True, padding=True) val_encodings = tokeniser(dev_data[&#39;premise&#39;], dev_data[&#39;hypothesis&#39;], truncation=True, padding=True) . Once the data has been tokenised we will create a NLIDataset object for our data. Here we are creating a subclass that inherits the torch.utils.data.Dataset class. . class NLIDataset(torch.utils.data.Dataset): def __init__(self, encodings, labels): self.encodings = encodings self.labels = labels def __getitem__(self, idx): item = {key: torch.tensor(val[idx]) for key, val in self.encodings.items()} item[&#39;labels&#39;] = torch.tensor(self.labels[idx]) return item def __len__(self): return len(self.encodings.input_ids) . Once we&#39;ve defined our dataset class we can initialise the training and validation datasets with our tokenised sentence pairs and labels. We will then create DataLoader objects for the training and validation data. . train_dataset = NLIDataset(train_encodings, train_labels) val_dataset = NLIDataset(val_encodings, val_labels) train_loader = DataLoader(train_dataset, batch_size=16, shuffle=True) val_loader = DataLoader(val_dataset, batch_size=16, shuffle=True) . Now, before we can start training, we need to import our model and optimiser to be used in training. We first set the device and use cuda if GPU is available. We then get the pre-trained DistilBERT model specifying the number of classes we are classifying to. . device = torch.device(&#39;cuda&#39;) if torch.cuda.is_available() else torch.device(&#39;cpu&#39;) model = DistilBertForSequenceClassification.from_pretrained(&#39;distilbert-base-uncased&#39;, num_labels=3) model.to(device) model.train() optim = AdamW(model.parameters(), lr=5e-5) . Now we are ready to train the model. In this demonstration we are fine-tuning for just three epochs, but you can change the value to something more meaningful if you like. Note that you could also use the Transformers Trainer class to fine-tune the model but I&#39;ve chosen to use native PyTorch instead. . epochs = 3 for epoch in range(epochs): all_losses = [] for batch in tqdm(train_loader, total=len(train_loader), desc=&quot;Epoch: {}/{}&quot;.format(epoch+1, epochs)): optim.zero_grad() input_ids = batch[&#39;input_ids&#39;].to(device) attention_mask = batch[&#39;attention_mask&#39;].to(device) labels = batch[&#39;labels&#39;].to(device) outputs = model(input_ids, attention_mask=attention_mask, labels=labels) loss = outputs[0] loss.backward() optim.step() all_losses.append(loss.item()) print(&quot; nMean loss: {:&lt;.4f}&quot;.format(np.mean(all_losses))) . Epoch: 1/3: 100%|██████████| 1250/1250 [15:31&lt;00:00, 1.34it/s] Epoch: 2/3: 0%| | 0/1250 [00:00&lt;?, ?it/s] . Mean loss: 0.8789 . Epoch: 2/3: 100%|██████████| 1250/1250 [15:27&lt;00:00, 1.35it/s] Epoch: 3/3: 0%| | 0/1250 [00:00&lt;?, ?it/s] . Mean loss: 0.5912 . Epoch: 3/3: 100%|██████████| 1250/1250 [15:27&lt;00:00, 1.35it/s] . Mean loss: 0.3316 . . Once the model has been trained we can evaluate it to get the validation accuracy for our model. . model.eval() with torch.no_grad(): eval_preds = [] eval_labels = [] for batch in tqdm(val_loader, total=len(val_loader)): input_ids = batch[&#39;input_ids&#39;].to(device) attention_mask = batch[&#39;attention_mask&#39;].to(device) labels = batch[&#39;labels&#39;].to(device) preds = model(input_ids, attention_mask=attention_mask, labels=labels) preds = preds[1].argmax(dim=-1) eval_preds.append(preds.cpu().numpy()) eval_labels.append(batch[&#39;labels&#39;].cpu().numpy()) print(&quot; nValidation accuracy: {:6.2f}&quot;.format(round(100 * (np.concatenate(eval_labels) == np.concatenate(eval_preds)).mean()), 2)) . 100%|██████████| 614/614 [02:26&lt;00:00, 4.18it/s] . Validation accuracy: 69.00 . . Now we are all done. As you can see the results are far from state of the art if you use just a fraction of the training data. . Hope you enjoyed this demo. Feel free to contact me if you have any questions. . Twitter: @AarneTalman | Website: talman.io | .",
            "url": "https://talman.io/nli/pytorch/demo/2020/12/11/natural-language-inference-with-pytorch-and-transformers.html",
            "relUrl": "/nli/pytorch/demo/2020/12/11/natural-language-inference-with-pytorch-and-transformers.html",
            "date": " • Dec 11, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "I’m a researcher in Language Technology at University of Helsinki. My research focuses on computational semantics, natural language understanding, machine translation and machine learning. . I work as the CTO at Nordcloud UK. I have 15 years of experience in software development, architecture, management consulting, startup business, AI/ML and NLP development and academic research. . Education . 2018 - present, PhD in Language Technology, University of Helsinki | 2005 - 2007, MSc in Computational Linguistics and Formal Grammar, King’s College London Graduated with Distinction. | 2002 - 2005, BSc in Philosophy, London School of Economics Graduated with First Class Honours. | . Employment . 2020 - present, CTO, Nordcloud UK | 2018 - 2020, Doctoral Researcher, Language Technology, University of Helsinki Working on computational semantics and natural language processing. | 2019 - present, Founder, Basement AI Basement AI is a Nordic artificial intelligence research lab specializing in natural language processing and machine learning. | 2015 - 2018, Associate Director, Consulting, Gartner. | 2012 - 2015, Consultant, Accenture. | 2011 - 2012, Research Student, London School of Economics. | 2009 - 2011, Product Manager, Nokia. | 2008 - 2009, Manager, Nokia. | 2006 - 2008, Systems Analyst, Tieto. | 2006 - 2006, Software Developer, Valuatum. | .",
          "url": "https://talman.io/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Publications and Talks",
          "content": "Academic Publications . Aarne Talman, Antti Suni, Hande Celikkanat, Sofoklis Kakouros, Jörg Tiedemann and Martti Vainio. 2019. Predicting Prosodic Prominence from Text with Pre-trained Contextualized Word Representations. Proceedings of NoDaLiDa 2019. [bibtex] [pdf] [corpus and code] | Aarne Talman, Umut Sulubacak, Raúl Vázquez, Yves Scherrer, Sami Virpioja, Alessandro Raganato, Arvi Hurskainen, and Jörg Tiedemann. 2019. The University of Helsinki submissions to the WMT19 news translation task. Proceedings of the Fourth Conference on Machine Translation: Shared Task Papers. [bibtex] [pdf] | Aarne Talman and Stergios Chatzikyriakidis. 2019. Testing the Generalization Power of Neural Network Models Across NLI Benchmarks. Proceedings of the 2019 ACL Workshop BlackboxNLP: Analyzing and Interpreting Neural Networks for NLP. [bibtex] [pdf] | Aarne Talman, Anssi Yli-Jyrä and Jörg Tiedemann. 2019. Sentence Embeddings in NLI with Iterative Refinement Encoders. Natural Language Engineering 25(4). [bibtex] [pdf] [code] | Academic Talks . Predicting Prosodic Prominence from Text with Pre-trained Contextualized Word Representations. 2 October 2019, NodaLiDa 2019, Turku. [pdf] | Neural Network models of NLI fail to capture the general notion of inference, 8 March 2019, CLASP Seminar, University of Gothenburg. [pdf] | State-of-the-Art Natural Language Inference Systems Fail to Capture the Semantics of Inference, 25 October 2018, Research Seminar in Language Technology, University of Helsinki. [pdf] | Natural Language Inference with Hierarchical BiLSTM’s, 28 September 2018, FoTran 2018. [pdf] | Natural Language Inference - Another Triumph for Deep Learning?, 23 November 2017, Research Seminar in Language Technology, University of Helsinki. [pdf] |",
          "url": "https://talman.io/publications/",
          "relUrl": "/publications/",
          "date": ""
      }
      
  

  
      ,"page4": {
          "title": "Resources",
          "content": "Software . Prosody: A system for predicting prosodic prominence from written text. License: MIT | Paper | . | Natural Language Inference: Natural language inference system written in Python and PyTorch implementing the HBMP sentence encoder. License: MIT | Paper | . | Data . Helsinki Prosody Corpus: The prosody corpus contains automatically generated, high quality prosodic annotations for the LibriTTS corpus (Zen et al. 2019) using the Continuous Wavelet Transform Annotation method (Suni et al. 2017). Language: English | License: CC BY 4.0 | Paper | . |",
          "url": "https://talman.io/resources/",
          "relUrl": "/resources/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
      ,"page9": {
          "title": "Teaching",
          "content": "University of Helsinki . Instructor: Natural Language Understanding and Representation Learning. Spring 2020. | Supervision: Learning and evaluation of multilingual rentence representations (Master Thesis) | Reading Group: Representation Learning for Natural Language Understanding. Autumn 2019. | Teaching Assistant: KIK-LG210 Machine Learning for Linguists. Spring 2019. | Teaching Assistant: LDA-T3115 A Practical Introduction to Modern Neural Machine Translation. Spring 2019. | . Other . Lab monitor / TA: 2019 Lisbon Machine Learning School (LxMLS 2019). | .",
          "url": "https://talman.io/teaching/",
          "relUrl": "/teaching/",
          "date": ""
      }
      
  

  
  

  
  

  
  

  
      ,"page13": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://talman.io/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}